#ifdef __BORLANDC__
#pragma option push -b
#pragma option push -a4
#endif

#ifdef FG_NAMESPACE
namespace fgl {
#endif

class FGWindow;
class FGControl;

/**
	The all event types.
	@ingroup Enums
*/
enum ENUM_EVENTS  {
/**
a dummy event.
*/
NOEVENT,
/**
This events indicates key pressing (the keyboard input is going to the active window only).
System has some reserved key combination (ALT+X, CTRL+TAB etc), and these aren't possible
to testing. These reserved keys are converted to appropriate events (QUITEVENT, LOSTFOCUSEVENT & GETFOCUSEVENT).
<b>Used with:</b> Application and Window handlers.
*/
KEYEVENT,
/**
Internal event.
*/
MOUSEEVENT,
/**
The last event, that is sent only to the application procedure. This event can generated
in one of the two ways: by user pressing <ALT+X> or by calling AppDone().
<b>Used with:</b> Application handler only.
*/
QUITEVENT,
/**
This is a very important event that is generated by system when you activate
some Controls (Button, EditBox, ..). The member key contains the id
of current control. The callback handler of the object [you can assign
to each Control your callback that will be called at the right time] is
called after this event parsing into your procedure. The test of some controls:
<b>Used with:</b> Application and Window handlers.

	void WindowHandler(GuiEvent *p)
	{
		switch(p->GetType())
		{
			case ACCELEVENT:
			if (p->GetKey() == button1->GetId())
			{
				// some code
			}
		}
	}
*/
ACCELEVENT,
/**
Last event in the app life. You can delete your stuff after this, the window is deleted now.
<b>Used with:</b> Window handlers only.
*/
TERMINATEEVENT,
/**
CLose  the most inner application loop only.
*/
CLOSEEVENT,
/**
Indicates any movement of the mouse (including button clicks). The members are
assigned as follows: If cursor is out of any window, member key is 0,
and items x & y contains the position of mouse cursor in screen co-ordination
([0,0] is top left corner). When the cursor is over some window, then event
is sent only to the active window. The key member is set to 0 if the window
is active, -1 when window with cursor is not active, and if the member key
is greater than 0, then value is an id of controls in window. The co-ordinations
for movement in case of window are relative to the window workspace (if cursor is
at the title of window, then y co-ordination will be negative!). For a good overview
of this, look at the events example.
<b>Used with:</b> Application and Window handlers.
*/
MOVEEVENT,
/**
This event is sent when a simple click on mouse's right button is detected. You must use window
flag WCLICKABLE to enable this feature. Position reported in the event
is in the screen co-ordinates, or relative to windows, according to placement.
<b>Used with:</b> Application and Window handlers.
*/
CLICKRIGHTEVENT,
/**
This event is sent when a simple click on mouse's left button is detected. You must use window
flag WCLICKABLE to enable this feature. Position reported in the event
is in the screen co-ordinates, or relative to windows, according to placement.
<b>Used with:</b> Application and Window handlers.
*/
CLICKLEFTEVENT,
/**
This event is sent when a simple click on mouse's middle button is detected. You must use window
flag WCLICKABLE to enable this feature. Position reported in the event
is in the screen co-ordinates, or relative to windows, according to placement.
<b>Used with:</b> Application and Window handlers.
*/
CLICKMIDDLEEVENT,
/**
<b>Used with:</b> Application and Window handlers.
*/
DRAGLEFTEVENT,
/**
<b>Used with:</b> Application and Window handlers.
*/
DRAGRIGHTEVENT,
/**
	The window has got the input focus.
	<b>Used with:</b> Window handlers only.
*/
GETFOCUSEVENT,
/**
	The window lost the input focus.
	<b>Used with:</b> Window handlers only.
*/
LOSTFOCUSEVENT,
/**
The first event that is sent to the window when a window is created and it is drawn
at the screen. It is a right place for drawing controls and other stuff.
<b>Used with:</b> Window handlers only.
*/
INITEVENT,
/**
If you hold the mouse button at the Controls PUSHBUTTON a while,
system will repeatedly emit this event. See also the SetRepeatDelay() function.
<b>Used with:</b> Application and Window handlers.
*/
BUTTONHOLDEVENT,
/**
If the window is resize-able (switch WSIZEABLE), then you can by dragging
bottom right corner of windows, resize one. After each size change,
this event is generated. You may redraw window at this point (Controls
are draws automatically). The current size (of window workspace)
is available by calling GetWW() a GetHW().
<b>Used with:</b> Window handlers only.
*/
WINDOWRESIZEEVENT,
/**
The event is generated when window moves at new position.
<b>Used with:</b> Window handlers only.
*/
WINDOWMOVEEVENT,
/**
If you use switch APP_MAGNIFIER, you can select a rectangle area by
the mouse dragging. The members are assigned with [x,y] position
of top left corner and [w,h] the size of one. If you want exactly
first and end point position of dragging, you must use GetDragVector().
<b>Used with:</b> Application and Window handlers.
*/
STARTDRAGLEFTEVENT,
/**
If you use switch APP_MAGNIFIER, you can select a rectangle area by
the mouse dragging. The members are assigned with [x,y] position
of top left corner and [w,h] the size of one. If you want exactly
first and end point position of dragging, you must use GetDragVector().
<b>Used with:</b> Application and Window handlers.
*/
STARTDRAGRIGHTEVENT,
/**
The window is repainted. Place your drawing code here.
<b>Used with:</b> Window handlers only.
*/
REPAINTEVENT,
/**
<b>Used with:</b> Window handlers only.
*/
NOTIFYEVENT,
/**
<b>Used with:</b> Window handlers only.
*/
ICONIZEEVENT,
/**
<b>Used with:</b> Application handler only.
*/
CURSOROUTEVENT,
/**
This event is sent when a double click on mouse's left button is detected. You must use window
flag WCLICKABLE to enable this feature. Position reported in the event
is in the screen co-ordinates (app handler), or relative to windows, according to placement.
<b>Used with:</b> Application and Window handlers.
*/
DBLCLICKRIGHTEVENT,
/**
This event is sent when a double click on mouse's right button is detected. You must use window
flag WCLICKABLE to enable this feature. Position reported in the event
is in the screen co-ordinates (app handler), or relative to windows, according to placement.
<b>Used with:</b> Application and Window handlers.
*/
DBLCLICKLEFTEVENT,
/**
This event is sent when a double click on mouse's middle button is detected. You must use window
flag WCLICKABLE to enable this feature. Position reported in the event
is in the screen co-ordinates (app handler), or relative to windows, according to placement.
<b>Used with:</b> Application and Window handlers.
*/
DBLCLICKMIDDLEEVENT,
/**
This event is sent when mouse's wheel spin is detected. You must use window
flag WCLICKABLE to enable this feature. GetButton() returns -1 or 1 for direcions. Position reported in the event
is in the screen co-ordinates (app handler), or relative to windows, according to placement.
<b>Used with:</b> Application and Window handlers.
*/
MOUSEWHEELEVENT,
/**
	Sent on the TabPage switch. The key member is pointer the name of one.
*/
TABSWITCHEVENT,
//! NOTE> this must be at the end - used as terminator.
LASTEVENT
};

/**
	System event object. The events are presents in many types. By example
	event is key pressing, mouse move, click on the mouse button, window move etc.
*/
class FGEvent
{
		friend class FGBaseGui;
		friend class FGApp;
		int		type;
		long	key;
		int		buttons, x,	y, w, h;
		/**
		This is a public member of FGEvent class and it is assigned for ACCELEVENT only.
		It contains the type of controls. Normally it is unnecessary. The types are
		enum ObjectType {WINDOW, CHECKBUTTON, e.g.
		*/
		int		guiType;

		static	const char *eventName[];
	protected:
	public:
		/**
		This is a public member of FGEvent class and it is initialised for
        window procedures only. It contains the pointer at the target window.
		It is useful when one procedure is assigned to more windows.
		Using of this member is in general better, than global pointers.
		*/
		FGWindow	*wnd;
		/**
		This is assigned for ACCELEVENT only.
		It contains the type of controls. Normally it is unnecessary. The types are
		enum ObjectType { WINDOW, CHECKBUTTON, e.g.
		*/
		int		GetObjectType(void) const { return guiType; }
		/**
		This is a public member of FGEvent class and it is initialised for
		window procedures only and ACCELEVENT only. It contains the pointer
		at the Controls that emit this event.
		*/
		FGControl *accel;
		/**
		Create the event of appropriate type. In the most cases, you will parse
		system events only. Creating of the events by the hand and sending them
		to other windows is less frequently. The response to the system events
		is adjusted into separate window procedures, each per window. This procedure
		is fact a one big switch statement with many cases.
		*/
		FGEvent(int T=NOEVENT,	int	K=0, int X=0, int Y=0, int W=0, int H=0)
			: type(T), key(K), x(X), y(Y), w(W), h(H), guiType(0), wnd(0), accel(0)
		{
		}
		//! Returns the value of key member of class FGEvent. As for event KEYEVENT, it return a key code.
		long		GetKey(void)  const { return key;	}
		//! Return a text string, which identified the name of events, or string "NONSENSE".
		const char	*GetName(void)  const { if (type<0 || type>=LASTEVENT) return eventName[LASTEVENT]; return eventName[type]; }
		//! Returns type of the event.
		int		GetType(void)  const { return	type; }
		//! Returns symbolic name of keycode as ASCIIZ string.
		static const char* GetKeySymbolName(unsigned int code);
		/**
		Returns an OR-ed value of the all mouse's buttons that are pushed.
		There are these symbolic values for buttons:
			-	FG_BUTTON_LEFT
			-	FG_BUTTON_RIGHT
			-	FG_BUTTON_MIDDLE
		*/
		int		GetButtons(void)  const {	return buttons;	}
		//! Returns x co-ordination for events that initialise this member (MOVEEVENT, CLICKLEFTEVENT).
		int		GetX(void)  const { return	x; }
		//! Returns y co-ordination for events that initialise this member (MOVEEVENT, CLICKLEFTEVENT).
		int		GetY(void)  const { return	y; }
		//! Returns a width.
		int		GetW(void)  const { return	w; }
		//! Returns a width.
		int		GetH(void)  const { return	h; }
};

/**
	Interface for user touchscreen + calibration framework.
*/
class FGInputDevice
{
	protected:
		bool working;

		struct POINT
		{
			int x, y;
		};

		struct MATRIX
		{
			/* This arrangement of values facilitates
			 *  calculations within getDisplayPoint()
			 */
			double An,					/* A = An/Divider */
			  Bn,						/* B = Bn/Divider */
			  Cn,						/* C = Cn/Divider */
			  Dn,						/* D = Dn/Divider */
			  En,						/* E = En/Divider */
			  Fn,						/* F = Fn/Divider */
			  Divider;
		};

		/* ( 15, 15)  */
		/* ( 50, 85)  */
		/* ( 85, 10)  */
		POINT imaginary[3];
		POINT real[3];
		MATRIX matrix;

		void init(int xmax, int ymax);
		void save_values(void);
		void load_values();
		int setCalibrationMatrix(POINT * display, POINT * screen, MATRIX * matrix);
		int getDisplayPoint(POINT * display, POINT * screen, MATRIX * matrix);
		void DoPoint(POINT * display, POINT * screen);
	public:
		FGInputDevice();
		virtual ~FGInputDevice() {}

		virtual bool Attach(void) = 0;
		virtual int GetInputEvent(int& type, long& key, int& x, int& y, int& button) = 0;
		virtual void Scale(int& x, int& y);

		void Calibration(void);
};

#ifdef _WIN32
#define PRTRSC	F12
#define	BACKSP	0x8
#define	KUP		0x126
#define	KDOWN	0x128
#define	KRIGHT	0x127
#define	KLEFT	0x125

#define	INSERT	0x12d
#define	DEL		0x12e
#define	HOME	0x124
#define	END		0x123
#define	PGUP	0x121
#define	PGDOWN	0x122

#define ALT_A	0x1061
#define ALT_B	(ALT_A+1)
#define ALT_C	(ALT_A+2)
#define ALT_D	(ALT_A+3)
#define ALT_E	(ALT_A+4)
#define ALT_F	(ALT_A+5)
#define ALT_G	(ALT_A+6)
#define ALT_H	(ALT_A+7)
#define ALT_I	(ALT_A+8)
#define ALT_J	(ALT_A+9)
#define ALT_K	(ALT_A+10)
#define ALT_L	(ALT_A+11)
#define ALT_M	(ALT_A+12)
#define ALT_N	(ALT_A+13)
#define ALT_O	(ALT_A+14)
#define ALT_P	(ALT_A+15)
#define ALT_Q	(ALT_A+16)
#define ALT_R	(ALT_A+17)
#define ALT_S	(ALT_A+18)
#define ALT_T	(ALT_A+19)
#define ALT_U	(ALT_A+20)
#define ALT_V	(ALT_A+21)
#define ALT_W	(ALT_A+22)
#define ALT_X	(ALT_A+23)
#define ALT_Y	(ALT_A+24)
#define	ALT_Z	(ALT_A+25)

#define	F01		0x270
#define	F02		(F01+1)
#define	F03		(F01+2)
#define	F04		(F01+3)
#define	F05		(F01+4)
#define	F06		(F01+5)
#define	F07		(F01+6)
#define	F08		(F01+7)
#define	F09		(F01+8)
#define	F10		(F01+9)
#define	F11		(F01+10)
#define	F12		(F01+11)

#define	ALT_F01		0x1201
#define	ALT_F02		0x1202
#define	ALT_F03		0x1203
#define	ALT_F04		0x1204
#define	ALT_F05		0x1205
#define	ALT_F06		0x1206
#define	ALT_F07		0x1207
#define	ALT_F08		0x1208
#define	ALT_F09		0x1209
#define	ALT_F10		0x120a
#define	ALT_F11		0x120b
#define	ALT_F12		0x120c

#define	CTRL_F01		0x401
#define	CTRL_F02		0x402
#define	CTRL_F03		0x403
#define	CTRL_F04		0x404
#define	CTRL_F05		0x405
#define	CTRL_F06		0x406
#define	CTRL_F07		0x407
#define	CTRL_F08		0x408
#define	CTRL_F09		0x409
#define	CTRL_F10		0x40a
#define	CTRL_F11		0x40b
#define	CTRL_F12		0x40c

#define	ALT_UP		(KUP+0x1000)
#define	ALT_DOWN	(KDOWN+0x1000)
#define	ALT_RIGHT 	(KRIGHT+0x1000)
#define	ALT_LEFT	(KLEFT+0x1000)

#define	ALT_TAB			4105
#define	ALT_INSERT		4642
#define	ALT_DEL			4223
#define	ALT_HOME		4664
#define	ALT_END			4665
#define ALT_PGUP		4662
#define ALT_PGDOWN		4663

#define	CTRL_UP		(KUP+0x100)
#define	CTRL_DOWN	(KDOWN+0x100)
#define	CTRL_RIGHT 	(KRIGHT+0x100)
#define	CTRL_LEFT	(KLEFT+0x100)

#define	CTRL_TAB		0xFFF
#define	CTRL_INSERT		802
#define	CTRL_DEL		0x7F
#define	CTRL_HOME		824
#define	CTRL_END		825
#define CTRL_PGUP	(PGUP+0x100)
#define CTRL_PGDOWN	(PGDOWN+0x100)
#endif

#if defined( __linux__ ) || defined( __rtems__ ) || defined(__sun__) || defined(__sun)
#define PRTRSC	0x21b
#define	BACKSP		0x8
#define	KUP		0x232
#define	KDOWN	0x233
#define	KRIGHT	0x235
#define	KLEFT	0x234

#define	INSERT	0x222
#define	DEL		0x7F
#define	HOME		0x238
#define	END		0x239
#define	PGUP	0x236
#define	PGDOWN	0x237

#define ALT_A	0x1061
#define ALT_B	(ALT_A+1)
#define ALT_C	(ALT_A+2)
#define ALT_D	(ALT_A+3)
#define ALT_E	(ALT_A+4)
#define ALT_F	(ALT_A+5)
#define ALT_G	(ALT_A+6)
#define ALT_H	(ALT_A+7)
#define ALT_I	(ALT_A+8)
#define ALT_J	(ALT_A+9)
#define ALT_K	(ALT_A+10)
#define ALT_L	(ALT_A+11)
#define ALT_M	(ALT_A+12)
#define ALT_N	(ALT_A+13)
#define ALT_O	(ALT_A+14)
#define ALT_P	(ALT_A+15)
#define ALT_Q	(ALT_A+16)
#define ALT_R	(ALT_A+17)
#define ALT_S	(ALT_A+18)
#define ALT_T	(ALT_A+19)
#define ALT_U	(ALT_A+20)
#define ALT_V	(ALT_A+21)
#define ALT_W	(ALT_A+22)
#define ALT_X	(ALT_A+23)
#define ALT_Y	(ALT_A+24)
#define	ALT_Z	(ALT_A+25)

#define	F01		0x301
#define	F02		(F01+1)
#define	F03		(F01+2)
#define	F04		(F01+3)
#define	F05		(F01+4)
#define	F06		(F01+5)
#define	F07		(F01+6)
#define	F08		(F01+7)
#define	F09		(F01+8)
#define	F10		(F01+9)
#define	F11		(F01+10)
#define	F12		(F01+11)

#define	ALT_F01		0x1201
#define	ALT_F02		0x1202
#define	ALT_F03		0x1203
#define	ALT_F04		0x1204
#define	ALT_F05		0x1205
#define	ALT_F06		0x1206
#define	ALT_F07		0x1207
#define	ALT_F08		0x1208
#define	ALT_F09		0x1209
#define	ALT_F10		0x120a
#define	ALT_F11		0x120b
#define	ALT_F12		0x120c

#define	CTRL_F01		0x401
#define	CTRL_F02		0x402
#define	CTRL_F03		0x403
#define	CTRL_F04		0x404
#define	CTRL_F05		0x405
#define	CTRL_F06		0x406
#define	CTRL_F07		0x407
#define	CTRL_F08		0x408
#define	CTRL_F09		0x409
#define	CTRL_F10		0x40a
#define	CTRL_F11		0x40b
#define	CTRL_F12		0x40c

#define	ALT_UP		(KUP+0x1000)
#define	ALT_DOWN	(KDOWN+0x1000)
#define	ALT_RIGHT 	(KRIGHT+0x1000)
#define	ALT_LEFT	(KLEFT+0x1000)

#define	ALT_TAB			0x1009
#define	ALT_INSERT		0x1222
#define	ALT_DEL			0x107f
#define	ALT_HOME		0x1238
#define	ALT_END			0x1239
#define ALT_PGUP		0x1236
#define ALT_PGDOWN		0x1237

#define	CTRL_UP		(KUP+0x100)
#define	CTRL_DOWN	(KDOWN+0x100)
#define	CTRL_RIGHT 	(KRIGHT+0x100)
#define	CTRL_LEFT	(KLEFT+0x100)

#define	CTRL_TAB		0xFFF
#define	CTRL_INSERT		0x322
#define	CTRL_DEL		0x7F
#define	CTRL_HOME		0x338
#define	CTRL_END		0x339
#define CTRL_PGUP	(PGUP+0x100)
#define CTRL_PGDOWN	(PGDOWN+0x100)
#endif //linux

#define CTRL_A	1
#define CTRL_B	2
#define CTRL_C	3
#define CTRL_D	4
#define CTRL_E	5
#define CTRL_F	6
#define CTRL_G	7
#define CTRL_H	8
#define CTRL_I	9
#define CTRL_J	10
#define CTRL_K	11
#define CTRL_L	12
#define CTRL_M	13
#define CTRL_N	14
#define CTRL_O	15
#define CTRL_P	16
#define CTRL_Q	17
#define CTRL_R	18
#define CTRL_S	19
#define CTRL_T	20
#define CTRL_U	21
#define CTRL_V	22
#define CTRL_W	23
#define CTRL_X	24
#define CTRL_Y	25
#define	CTRL_Z	26

/**
The type of a FGWindow handler. This procedure is called when the FGWindow EVENT (of type FGEvent) is occured.
*/
typedef	void (*GuiHwnd)(FGEvent *);

#ifdef FG_NAMESPACE
}
#endif

#ifdef __BORLANDC__
#pragma option pop /* pop -a switch */
#pragma option pop /* pop -b */
#endif

